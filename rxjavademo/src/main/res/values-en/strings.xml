<resources>
    <string name="app_name">RxJava Example</string>

    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>

    <string name="action_settings">Settings</string>

    <string name="communicate">Communication</string>
    <string name="action_share">Share</string>
    <string name="action_send">Send Example APK</string>
    <string name="api">API Example</string>
    <string name="sample">Case Example</string>
    <string name="source_code">SourceCode：https://github.com/leeowenowen/rxjava-examples
        .git</string>
    <string name="dev_by">Developer：Lee Wang (Alibaba_UC_Union)</string>

    <string name="desc_utility_materialize">convert an Observable into a list of
        Notifications, [dematerialize:convert a materialized Observable back into its
        non-materialized form]</string>
    <string name="desc_utility_timestamp">attach a timestamp to every item emitted by an Observable</string>
    <string name="desc_utility_serialize">force an Observable to make serialized calls and to be well-behaved</string>
    <string name="desc_utility_cache">remember the sequence of items emitted by the Observable and emit the same sequence to future Subscribers</string>
    <string name="desc_utility_observeOn">specify on which Scheduler a Subscriber should observe the Observable</string>
    <string name="desc_utility_subscribeOn"> specify which Scheduler an Observable should use when its subscription is invoked</string>
    <string name="desc_utility_doOnEach">register an action to take whenever an Observable emits an item</string>
    <string name="desc_utility_doOnCompleted"> register an action to take when an Observable completes successfully</string>
    <string name="desc_utility_doOnError">register an action to take when an Observable completes with an error</string>
    <string name="desc_utility_doOnTerminate">register an action to take when an Observable completes, either successfully or with an error</string>
    <string name="desc_utility_doOnSubscribe">register an action to take when an observer subscribes to an Observable</string>
    <string name="desc_utility_doOnUnsubscribe"> register an action to take when an observer subscribes to an Observable</string>
    <string name="desc_utility_finallyDo"> register an action to take when an Observable completes</string>
    <string name="desc_utility_delay"> shift the emissions from an Observable forward in time by a specified amount</string>
    <string name="desc_utility_delaySubscription"> hold an Subscriber\'s subscription request for a specified amount of time before passing it on to the source Observable</string>
    <string name="desc_utility_timeInterval"> emit the time lapsed between consecutive emissions of a source Observable</string>
    <string name="desc_utility_using">create a disposable resource that has the same lifespan as an Observable</string>
    <string name="desc_utility_single"> if the Observable completes after emitting a single item, return that item, otherwise throw an exception</string>
    <string name="desc_utility_singleOrDefault"> if the Observable completes after emitting a single item, return that item, otherwise return a default item</string>

    <string name="desc_transformation_map"> transform the items emitted by an Observable by applying a function to each of them</string>
    <string name="desc_transformation_flatMap">transform the items emitted by an Observable into Observables (or Iterables), then flatten this into a single Observable</string>
    <string name="desc_transformation_concatMap">transform the items emitted by an Observable into Observables (or Iterables), then flatten this into a single Observable</string>
    <string name="desc_transformation_flatMapIterable">transform the items emitted by an Observable into Observables (or Iterables), then flatten this into a single Observable</string>
    <string name="desc_transformation_switchMap">transform the items emitted by an Observable into Observables, and mirror those items emitted by the most-recently transformed Observable</string>
    <string name="desc_transformation_scan">apply a function to each item emitted by an Observable, sequentially, and emit each successive value</string>
    <string name="desc_transformation_groupBy"> divide an Observable into a set of Observables that emit groups of items from the original Observable, organized by key</string>
    <string name="desc_transformation_buffer"> periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</string>
    <string name="desc_transformation_window">periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</string>
    <string name="desc_transformation_cast">cast all items from the source Observable into a particular type before reemitting them</string>

    <string name="desc_subject_async">AsyncSubject caches the last value. The difference now is
        that it doesn\'t emit anything
    until the sequence completes. Its use is to emit a single value and immediately complete.</string>
    <string name="desc_subject_behavior">BehaviorSubject only remembers the last value. It is similar to a ReplaySubject with a
    buffer of size 1. An initial value can be provided on creation, therefore guaranteeing that
     a value always will be available immediately on subscription.</string>
    <string name="desc_subject_behavior_with_init_value">BehaviorSubject only remembers the last value. It is similar to a ReplaySubject with a
    buffer of size 1. An initial value can be provided on creation, therefore guaranteeing that
     a value always will be available immediately on subscription.</string>
    <string name="desc_subject_publish">PublishSubject is the most straight-forward kind of subject.
     When a value is pushed into a PublishSubject, the subject pushes
     it to every subscriber that is subscribed to it at that moment.</string>
    <string name="desc_subject_replay">ReplaySubject has the special feature of caching all the values pushed to it. When a new
      subscription is made, the event sequence is replayed from the start for the new subscriber.
      After catching up, every subscriber receives new events as they come.</string>
    <string name="desc_subject_replay_create_with_time">ReplaySubject has the special feature of caching all the values pushed to it. When a new
      subscription is made, the event sequence is replayed from the start for the new subscriber.
      After catching up, every subscriber receives new events as they come.</string>


    <string name="desc_string_byline">converts an Observable of Strings into an Observable of Lines by treating the source sequence as a stream and splitting it on line-endings</string>
    <string name="desc_string_decode">convert a stream of multibyte characters into an Observable that emits byte arrays that respect character boundaries</string>
    <string name="desc_string_encode"> transform an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings</string>
    <string name="desc_string_from">convert a stream of characters or a Reader into an Observable that emits byte arrays or Strings</string>
    <string name="desc_string_join">converts an Observable that emits a sequence of strings into an Observable that emits a single string that concatenates them all, separating them by a specified string</string>
    <string name="desc_string_split">converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary</string>
    <string name="desc_string_stringConcat">converts an Observable that emits a sequence of strings into an Observable that emits a single string that concatenates them all</string>

    <string name="desc_scheduler_io">exectute task on  io  thread</string>
    <string name="desc_scheduler_compute">exectute   task    on  compute  thread</string>
    <string name="desc_scheduler_immediate">exectute   task  immediately  on  current
        thread</string>
    <string name="desc_scheduler_self_define">exectute   task    on  io  thread</string>
    <string name="desc_scheduler_new_thread">exectute task on a new thread</string>
    <string name="desc_scheduler_trampoline">push   the task to the end of  the current
        thread  task    queue</string>

    <string name="desc_reactive_stream_materialize"></string>
    <string name="desc_plugin_start_hook"></string>

    <string name="desc_observable_create_just">convert an object or several objects into an Observable that emits that object or those objects</string>
    <string name="desc_observable_create_from_future">convert a Future, into an Observable</string>
    <string name="desc_observable_create_from_iterable">convert an Iterable into an Observable</string>
    <string name="desc_observable_create_repeat">create an Observable that emits a particular item or sequence of items repeatedly</string>
    <string name="desc_observable_create_repeatWhen">create an Observable that emits a particular item or sequence of items repeatedly, depending on the emissions of a second Observable</string>
    <string name="desc_observable_create_create">create an Observable from scratch by means of a function</string>
    <string name="desc_observable_create_defer">do not create the Observable until a Subscriber subscribes; create a fresh Observable on each subscription</string>
    <string name="desc_observable_create_range">create an Observable that emits a range of sequential integers</string>
    <string name="desc_observable_create_interval">create an Observable that emits a sequence of integers spaced by a given time interval</string>
    <string name="desc_observable_create_timer">create an Observable that emits a single item after a given delay</string>
    <string name="desc_observable_create_empty">create an Observable that emits nothing and then completes</string>
    <string name="desc_observable_create_error">create an Observable that emits nothing and then signals an error</string>
    <string name="desc_observable_create_never">create an Observable that emits nothing at all</string>

    <string name="desc_math_averageInteger">calculates the average of Integers emitted by an Observable and emits this average</string>
    <string name="desc_math_averageLong">calculates the average of Longs emitted by an Observable and emits this average</string>
    <string name="desc_math_averageFloat"> calculates the average of Floats emitted by an Observable and emits this average</string>
    <string name="desc_math_averageDouble"> calculates the average of Doubles emitted by an Observable and emits this average</string>
    <string name="desc_math_max">emits the maximum value emitted by a source Observable</string>
    <string name="desc_math_maxBy">emits the item emitted by the source Observable that has the maximum key value</string>
    <string name="desc_math_min">emits the minimum value emitted by a source Observable</string>
    <string name="desc_math_minBy"> emits the item emitted by the source Observable that has the minimum key value</string>
    <string name="desc_math_sumInteger">adds the Integers emitted by an Observable and emits this sum</string>
    <string name="desc_math_sumLong">adds the Longs emitted by an Observable and emits this sum</string>
    <string name="desc_math_sumFloat">adds the Floats emitted by an Observable and emits this sum</string>
    <string name="desc_math_sumDouble">adds the Doubles emitted by an Observable and emits this sum</string>

    <string name="desc_math_concat">concatenate two or more Observables sequentially</string>
    <string name="desc_math_count"> counts the number of items emitted by an Observable and emits this count</string>
    <string name="desc_math_countLong"> counts the number of items emitted by an Observable and emits this count</string>
    <string name="desc_math_reduce">apply a function to each emitted item, sequentially, and emit only the final accumulated value</string>
    <string name="desc_math_collect">collect items emitted by the source Observable into a single mutable data structure and return an Observable that emits this structure</string>
    <string name="desc_math_toList">collect all items from an Observable and emit them as a single List</string>
    <string name="desc_math_toSortedList">collect all items from an Observable and emit them as a single, sorted List</string>
    <string name="desc_math_toMap">convert the sequence of items emitted by an Observable into a map keyed by a specified key function</string>
    <string name="desc_math_toMultiMap">convert the sequence of items emitted by an Observable into an ArrayList that is also a map keyed by a specified key function</string>

    <string name="desc_filter_filter">filter items emitted by an Observable</string>
    <string name="desc_filter_takeLast">only emit the last n items emitted by an Observable</string>
    <string name="desc_filter_last">emit only the last item emitted by an Observable</string>
    <string name="desc_filter_lastOrDefault">emit only the last item emitted by an Observable, or a default value if the source Observable is empty</string>
    <string name="desc_filter_takeLastBuffer">emit the last n items emitted by an Observable, as a single list item</string>
    <string name="desc_filter_skip"> ignore the first n items emitted by an Observable</string>
    <string name="desc_filter_skipLast"> ignore the last n items emitted by an Observable</string>
    <string name="desc_filter_take">emit only the first n items emitted by an Observable</string>
    <string name="desc_filter_first">emit only the first item emitted by an Observable, or the first item that meets some condition</string>
    <string name="desc_filter_takeFirst">emit only the first item emitted by an Observable</string>
    <string name="desc_filter_firstOrDefault">emit only the first item  emitted by an Observable that meets some condition</string>
    <string name="desc_filter_elementAt"> emit item n emitted by the source Observable</string>
    <string name="desc_filter_elementAtOrDefault">emit item n emitted by the source Observable, or a default item if the source Observable emits fewer than n items</string>
    <string name="desc_filter_sample">emit the most recent items emitted by an Observable within periodic time intervals</string>
    <string name="desc_filter_throttleLast">emit the most recent items emitted by an Observable within periodic time intervals</string>
    <string name="desc_filter_throttleFirst">emit the first items emitted by an Observable within periodic time intervals</string>
    <string name="desc_filter_throttleWithTimeout">only emit an item from the source Observable after a particular timespan has passed without the Observable emitting any other items</string>
    <string name="desc_filter_debounce">only emit an item from the source Observable after a particular timespan has passed without the Observable emitting any other items</string>
    <string name="desc_filter_timeout">emit items from a source Observable, but issue an exception if no item is emitted in a specified timespan</string>
    <string name="desc_filter_distinct"> suppress duplicate items emitted by the source Observable</string>
    <string name="desc_filter_distinctUntilChanged"> suppress duplicate consecutive items emitted by the source Observable</string>
    <string name="desc_filter_ofType">emit only those items from the source Observable that are of a particular class</string>
    <string name="desc_filter_ignoreElements"> discard the items emitted by the source Observable and only pass through the error or completed notification</string>

    <string name="desc_error_handler_onErrorResumeNext">instructs an Observable to emit a sequence of items if it encounters an error</string>
    <string name="desc_error_handler_onErrorReturn"> instructs an Observable to emit a particular item when it encounters an error</string>
    <string name="desc_error_handler_onExceptionResumeNext"> instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)</string>
    <string name="desc_error_handler_retry"> if a source Observable emits an error, resubscribe to it in the hopes that it will complete without error</string>
    <string name="desc_error_handler_retryWhen">if a source Observable emits an error, pass that error to another Observable to determine whether to resubscribe to the source</string>

    <string name="desc_custormer_operator_customeOperator"></string>
    <string name="desc_connectable_obervable_connect">instructs a Connectable Observable to begin emitting items</string>
    <string name="desc_connectable_obervable_publish"> represents an Observable as a Connectable Observable</string>
    <string name="desc_connectable_obervable_replay">ensures that all Subscribers see the same sequence of emitted items, even if they subscribe after the Observable begins emitting the items</string>
    <string name="desc_connectable_obervable_refCount"> makes a Connectable Observable behave like an ordinary Observable</string>

    <string name="desc_condition_amb"> given two or more source Observables, emits all of the items from the first of these Observables to emit an item</string>
    <string name="desc_condition_defaultIfEmpty">emit items from the source Observable, or emit a default item if the source Observable completes after emitting no items</string>
    <string name="desc_condition_doWhile">emit the source Observable\'s sequence, and then repeat the sequence as long as a condition remains true</string>
    <string name="desc_condition_ifThen">only emit the source Observable\'s sequence if a condition is true, otherwise emit an empty or default sequence</string>
    <string name="desc_condition_skipUtil">discard items emitted by a source Observable until a second Observable emits an item, then emit the remainder of the source Observable\'s items</string>
    <string name="desc_condition_skipWhile"> discard items emitted by an Observable until a specified condition is false, then emit the remainder</string>
    <string name="desc_condition_switchcase"> emit the sequence from a particular Observable based on the results of an evaluation</string>
    <string name="desc_condition_takeUntil">emits the items from the source Observable until a second Observable emits an item or issues a notification</string>
    <string name="desc_condition_takeWhile">emit items emitted by an Observable as long as a specified condition is true, then skip the remainder</string>
    <string name="desc_condition_takeWhileWithIndex">emit items emitted by an Observable as long as a specified condition is true, then skip the remainder</string>
    <string name="desc_condition_WhileDo">if a condition is true, emit the source Observable\'s sequence and then repeat the sequence as long as the condition remains true</string>

    <string name="desc_condition_all">determine whether all items emitted by an Observable meet some criteria</string>
    <string name="desc_condition_contains">determine whether an Observable emits a particular item or not</string>
    <string name="desc_condition_exists">determine whether an Observable emits any items or
        not</string>
    <string name="desc_condition_isEmpty">determine whether an Observable emits any items or not</string>
    <string name="desc_condition_sequenceEqual"> test the equality of the sequences emitted by two Observables</string>

    <string name="desc_combine_startWith">emit a specified sequence of items before beginning to emit the items from the Observable</string>
    <string name="desc_combine_merge">combine multiple Observables into one</string>
    <string name="desc_combine_mergeDelayError">combine multiple Observables into one, allowing error-free Observables to continue before propagating errors</string>
    <string name="desc_combine_zip">combine sets of items emitted by two or more Observables together via a specified function and emit items based on the results of this function</string>
    <string name="desc_combine_and_then_when">combine sets of items emitted by two or more Observables by means of Pattern and Plan intermediaries</string>
    <string name="desc_combine_combineLatest">when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</string>
    <string name="desc_combine_join">combine the items emitted by two Observables whenever one item from one Observable falls within a window of duration specified by an item emitted by the other Observable</string>
    <string name="desc_combine_groupjoin">combine the items emitted by two Observables whenever one item from one Observable falls within a window of duration specified by an item emitted by the other Observable</string>
    <string name="desc_combine_switchIfEmpty"></string>
    <string name="desc_combine_switchOnNext">convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently emitted of those Observables</string>

    <string name="desc_blocking_observable_forEach"> invoke a function on each item emitted by the Observable; block until the Observable completes</string>
    <string name="desc_blocking_observable_first">block until the Observable emits an item, then return the first item emitted by the Observable</string>
    <string name="desc_blocking_observable_firstOrDefault">block until the Observable emits an item or completes, then return the first item emitted by the Observable or a default item if the Observable did not emit an item</string>
    <string name="desc_blocking_observable_last">block until the Observable completes, then return the last item emitted by the Observable</string>
    <string name="desc_blocking_observable_lastOrDefault">block until the Observable completes, then return the last item emitted by the Observable or a default item if there is no last item</string>
    <string name="desc_blocking_observable_mostRecent">returns an iterable that always returns the item most recently emitted by the Observable</string>
    <string name="desc_blocking_observable_next">returns an iterable that blocks until the Observable emits another item, then returns that item</string>
    <string name="desc_blocking_observable_latest">returns an iterable that blocks until or unless the Observable emits an item that has not been returned by the iterable, then returns that item</string>
    <string name="desc_blocking_observable_single">if the Observable completes after emitting a single item, return that item, otherwise throw an exception</string>
    <string name="desc_blocking_observable_singleOrDefault">if the Observable completes after emitting a single item, return that item, otherwise return a default item</string>
    <string name="desc_blocking_observable_toFuture">convert the Observable into a Future</string>
    <string name="desc_blocking_observable_toIterable">convert the sequence emitted by the Observable into an Iterable</string>
    <string name="desc_blocking_observable_getIterator">convert the sequence emitted by the Observable into an Iterator</string>


    <string name="desc_async_start"> create an Observable that emits the return value of a function</string>
    <string name="desc_async_toAsync">convert a function or Action into an Observable that executes the function and emits its return value</string>
    <string name="desc_async_startFuture">convert a function that returns Future into an Observable that emits that Future\'s return value</string>
    <string name="desc_async_deferFuture">convert a Future that returns an Observable into an Observable, but do not attempt to get the Observable that the Future returns until a Subscriber subscribes</string>
    <string name="desc_async_forEachFuture">pass Subscriber methods to an Observable but also have it behave like a Future that blocks until it completes</string>
    <string name="desc_async_fromAction"> convert an Action into an Observable that invokes the action and emits its result when a Subscriber subscribes</string>
    <string name="desc_async_fromCallable">convert a Callable into an Observable that invokes the callable and emits its result or exception when a Subscriber subscribes</string>
    <string name="desc_async_fromRunnable">convert a Runnable into an Observable that invokes the runable and emits its result when a Subscriber subscribes</string>
    <string name="desc_async_runAsync"> returns a StoppableObservable that emits multiple actions as generated by a specified Action on a Scheduler</string>
</resources>
